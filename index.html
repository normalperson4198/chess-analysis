<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Chess Analysis</title>

<link rel="stylesheet"
href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css"/>

<style>
  body {
    font-family: Arial, sans-serif;
    background: #111;
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
  }

  #board { width: 400px; margin-bottom: 15px; }
  button { padding: 10px 16px; font-size: 16px; cursor: pointer; margin: 5px; }
  #output, #moveList {
    background: #222; padding: 10px; width: 400px; font-family: monospace; margin-bottom: 10px;
  }
  #pgnInput { width: 400px; margin-bottom: 10px; padding: 6px; }
</style>
</head>
<body>

<h1>Chess Analysis</h1>

<div id="board"></div>

<input type="text" id="fenInput" placeholder="Enter FEN" />
<button onclick="loadFEN()">Load FEN</button>

<textarea id="pgnInput" placeholder="Paste PGN here" rows="4"></textarea>
<button onclick="loadPGN()">Load PGN</button>

<div>
  <button onclick="prevMove()">← Previous Move</button>
  <button onclick="nextMove()">Next Move →</button>
  <button onclick="analyze()">Analyze</button>
</div>

<div id="output">Engine output…</div>
<div id="moveList">Moves with annotations will appear here.</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>

<script>
const game = new Chess();
let moveHistory = [];
let currentMoveIndex = -1;
let moveAnnotations = [];

const board = Chessboard("board", {
  draggable: true,
  position: "start",
  pieceTheme: "https://cdn.jsdelivr.net/gh/oakmac/chessboardjs@1.0.0/website/img/chesspieces/wikipedia/{piece}.png",
  onDrop: (source, target) => {
    const move = game.move({from: source, to: target, promotion: "q"});
    if (move === null) return "snapback";
  }
});

// --- STOCKFISH ---
const engine = new Worker("./engine/stockfish.js");
engine.onmessage = (e) => {
  const line = e.data;
  if (line.includes("info depth") && line.includes("score")) {
    document.getElementById("output").textContent = line;
  }
  if (line.includes("bestmove")) {
    document.getElementById("output").textContent = line;
  }
};
engine.postMessage("uci");
engine.postMessage("isready");

function analyze() {
  engine.postMessage("position fen " + game.fen());
  engine.postMessage("go depth 15");
}

// --- FEN ---
function loadFEN() {
  const fen = document.getElementById("fenInput").value.trim();
  if (!fen) return;
  const valid = game.validate_fen(fen);
  if (!valid.valid) { alert("Invalid FEN: " + valid.error); return; }

  game.load(fen);
  board.position(fen);
  moveHistory = [];
  currentMoveIndex = -1;
  document.getElementById("output").textContent = "FEN loaded!";
  document.getElementById("moveList").textContent = "";
}

// --- PGN ---
function loadPGN() {
  const pgn = document.getElementById("pgnInput").value.trim();
  if (!pgn) return;
  const loaded = game.load_pgn(pgn);
  if (!loaded) { alert("Invalid PGN"); return; }

  moveHistory = game.history();
  currentMoveIndex = -1;      // Start at the beginning
  game.reset();               // Reset board to starting position
  board.position(game.fen());
  document.getElementById("output").textContent = "PGN loaded!";
  document.getElementById("moveList").textContent = "";

  // Precompute annotations
  annotateMoves();
}

// Very simple async Stockfish evaluation
async function getStockfishEval(fen) {
  return new Promise(resolve => {
    const tempWorker = new Worker("./engine/stockfish.js");
    tempWorker.onmessage = (e) => {
      const line = e.data;
      if (line.includes("bestmove")) tempWorker.terminate();
      const m = line.match(/score cp (-?\d+)/);
      if (m) resolve(parseInt(m[1]));
    };
    tempWorker.postMessage("uci");
    tempWorker.postMessage("isready");
    tempWorker.postMessage("position fen " + fen);
    tempWorker.postMessage("go depth 10"); // fast, adjust as needed
  });
}

let evalHistory = []; // Stores Stockfish evaluation for each move

async function annotateMoves() {
  moveAnnotations = [];
  evalHistory = [];

  const tempGame = new Chess();
  for (let i = 0; i < moveHistory.length; i++) {
    const fenBefore = tempGame.fen();
    tempGame.move(moveHistory[i]);
    const fenAfter = tempGame.fen();

    // Stockfish evals
    const evalBefore = await getStockfishEval(fenBefore);
    const evalAfter = await getStockfishEval(fenAfter);
    
    evalHistory.push(evalAfter);

    // Compute delta from the perspective of the side who just moved
    const delta = (tempGame.turn() === 'w') 
                  ? evalBefore - evalAfter 
                  : evalAfter - evalBefore;

    const category = getMoveCategory(delta);
    moveAnnotations.push(`${moveHistory[i]} → ${category}`);
  }
}

// Use annotations when navigating
function nextMove() {
  if (currentMoveIndex >= moveHistory.length - 1) return;
  currentMoveIndex++;
  game.move(moveHistory[currentMoveIndex]);
  board.position(game.fen());

  document.getElementById("moveList").textContent =
    moveAnnotations[currentMoveIndex] || "";
}

function prevMove() {
  if (currentMoveIndex < 0) return;
  game.undo();
  currentMoveIndex--;
  board.position(game.fen());

  if (currentMoveIndex >= 0)
    document.getElementById("moveList").textContent =
      moveAnnotations[currentMoveIndex] || "";
  else
    document.getElementById("moveList").textContent = "";
}
</script>

</body>
</html>
